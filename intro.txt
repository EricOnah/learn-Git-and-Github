# This is a git crash course for self

git init: to initialize a repository. This will make Git track the activities in that folder. Once the folder is created
initialized, you should not run this command again in the child folders.

git status: to check the status of a repository or if there's a repo at all.

to remove git repo from the directory, delete the .git directory.

code: ls -a #to see hidden files and directories
        rm -rf .git #to remove the git directory

#Once done, git no longer tracks the folder.

#Best practice will be to only initialize project directories individually.



git commit: check point in time. As you work can commit different changes to your file or project and have it saved 
on github with a description of the changes.

3 things here:
Working directory: Folder where you work is saved on

Staging area: Where the selected files you want to commit are kept before commit. code: git add
you can also use code: git stage filename  #to add files in the staging area.
to remove file or files from the staging area - code: git rm --cached filename. or git restore --staged filename.
If there is a change in the staged file and the one in the working directory, the removed command will not be executed.
Two things you can do in this case:
- Stage the file again and and run the git rm command again
- force remove the file by running git rm command with -f. Code: rm --cached -f "filename"

Repository: the .git folder that was created when you initialized git. This is where the files in the staging area area
gets added once you commit. code: git commit

commit message: commit message carries information about the files or changes that you made in the file that is about to be
to be committed. code: git commit -m "#commit message"

##more git add and git commit commands


git add . ##stage all changes in the folder at once
git add <path> : Use git add to stage a specific file or directory.
git add -p : Use an interactive mode to choose which hunks of changes to stage.



##keep each commit focused on a single change (Atomic Commit)
##to get more options visit - https://git-scm.com/docs


##GIT log
displays information about the commit. code: git log

to have it display in one line - code: git log --oneline

##to get more options visit - https://git-scm.com/docs



##Amending mistakes in commit

If you omitted a file or had typo in commit message, you can amend it.
Stage in the file you forgot to add and run the code below
code: git commit --amend
In the file that will open in your code editor, you can edit the commit message, check if the new file has been 
added then close the file.
##this is only used to amend the last commit not 2 or 3 commits earlier

To amend earlier commits use git rebase. code: git rebase -i HEAD~n (number of commits) if n is 3, it will display the
last 3 commits.


##GIT IGNORE HEAD

To make git not track every file in your project you can use the .gitignore file to hide these files and folders
from git.

you can add file extension e.g .txt or folder ignore_this/

for files to ignore while working on a project visit: https://www.toptal.com/developers/gitignore/



##Branches (Alternative timelines) - Alternative timeline where you can work on the project but in a different timeline 
that the main branch or the parent branch is not affected by the changes you make in the new branch.

##HEAD = current branch

to see current branches - code: git branch
if there is more than one branch, the branch name with * is the branch you are on.
 
To create a new branch - code: git branch <branch-name> ##this doesn't switch you to the branch just creates.

To switch to a new branch - code: git switch <branch-name>

##changes committed to a branch can only be seen when on that branch.

To rename a branch - git branch -m <new name>

To create a new branch and switch to the new branch you add -c to switch. - code: git switch -c <branch-name>

To delete a branch - git branch --delete <branch-name> or git branch -d(or D for forced delete) <branch>

To restore a deleted branch - copy the SHA value of the deleted branch, use git checkout to switch to the SHA value
as a detached head then use git switch -c <branch name> to create and switch to a new branch contain all the commits
in the former branch.

You can also use git reset SHA1 to go back to the commit of the deleted branch and use git switch -c <branch name> to
create a new branch from the old branch.

NOTE: Every commit before after SHA1 of the deleted branch will be lost.

NOTE: If you cannot see the SHA value of the deleted branch, use git reflog to the SHA of the branch deleted and
follow the process above.

#Merge

## You can use merge to merge different branches. It could be a fast forward merge, merge commit or merge conflict.
Fast Forward Merge: Merging branches that have the same files but some changes in one branch is not in the other.
These changes do not conflict with the file on the second branch so the merge is seamless.
Merge Commit: Merging branches that have new files in one or both branches. The merge will just commit these files and
Merge Conflict: Merging branches that the same files but different changes have been made to one or more of the files in the other branch
each of the branch so there is conflict to resolve before the merge is completed.


code: git merge <branch name>

##git diff
Used to see differences between between files in unstaged area and files in staged area.

code: git diff

git diff HEAD - used to see the changes in working directory compared to the last commit in the

git diff --staged - shows the changes in staged area compared to the last commit

git diff --cached - shows the changes in staged area compared to the last commit

git diff shows the differences between the stagging area and working directory. The - is the stagging area
while the + is the working directory. You can compare and see what is not stagged yet.

git diff can be used on specific files ba adding the filename
git diff tips.text
this can used on all git diff commands (HEAD, --staged or --cached)

git diff can be used to compare two branches. code: git diff branchname...2ndbranchname

to compare specific files in both branches, add the filename after the ...2ndbranchname


##git stash - used to save changes without staging or committing it so you can easily switch branches without
losing your work.
To recover the changes - git stash pop

To apply the changes you stash and still have them in the stash to be used again you use - git stash apply

When you have multiple stashes because you were using apply instead of pop, you can use - git stash list
to see all the stashed list

To apply any of the stash in the list you can use - git stash apply stash@{stash number}

To clean up the stash you can use - git stash drop stash@{stash number}


##git checkout - 

You can use this to switch to any commit code git checkout <commit hash>

This will remove every changes made after the commit you switch to. The changes are not lost. Once you switch back to 
the branch that houses the changes, you have them back.(Re-attaching detached HEAD)

You can also reference commits relative to the HEAD by using git checkout HEAD~<n> where is the location of the commit
from the head. e.g git checkout HEAD~1 (meaning the first commit after HEAD)
NOTE: HEAD is the commit or branch you're in. you can always check what HEAD is with git log

To revert immediate changes to in you document you can use git checkout to a previous commit or the HEAD

git checkout <commit hash> or git checkout HEAD~<position of commit from HEAD>

When you checkout to an old commit, you can start a new branch or a new commit based on the old commit you are in.

you can use git checkout -- <filename> for the above function as well. This will revert to the HEAD.
 NOTE: This will only revert unstaged and uncommitted changes.

 ##git restore 
 performs similar function like the checkout above. git restore doesn't detach from the head into a commit.
 It reverts the unstaged uncommitted changes without leaving the current HEAD.
 To specify a particular commit, you use git restore --source <HEAD~n> or <commit hash> file(s)name
 
 git restore --staged <filename> can be used to unstage a staged file.
 To revert a staged file to previous commit, use git restore --staged <filename> to first unstage it
 then use git restore <filename> to revert the changes.


##git reset <commit hash> or <HEAD~n>
This is used to delete a commit from the top. for you reset to a 3 commits ago, the most recent commits will be removed
 This can not be used to delete a targeted commit like first commit only it will all commits that came after that
 git reset --hard <commit hash> removes all unstaged changes in the working directory


 ##git revert <commit hash> or <HEAD~n>
 This will revert changes to a commit but won't delete the commit rather creats a new commit as the HEAD containing
 the changes or correction made.
 You can also use git revert to merge commits (i.e changes in different commits)

##git clone <url> used to clone a repo from a remote source to your machine.
Note: Run git clone in a folder where git has not been initialized because it initializes git.

##Github

Two ways to upload or add a new repo on the github

When the project hasn't started: create an empty repo on github and clone it to your project directory and start
working and uploading.

When you have a repo on your machine: create a github repo and connect it to the repo o your local machine.

origin - a conventional git remote name. it's just a name for a url and can be renamed

A remote is a url that we make git aware of that we can upload files to from git. (A repo that is not on our machine
which needs a url so we can link it to our machine and a label to identify it so we can remotely push things into it)

To add a remote, git remote add <label(origin)> <repo url>

To rename a remote - git remote rename <old name> <new name>

To remove a remote - git remote remove <name>

It is possible to have a multiple remote


#SSH setup - this is used to set secure your activities between your machine and the server
 To do this, visit https://docs.github.com/en/authentication/connecting-to-github-with-ssh
 
check if you have SSH generated already - click on "checking for existing SSH keys" choose your machine and
copy the code for your machine. code(windows) - ls -al ~/.ssh

Once you confirm you do not have SSH key already, click on "Generate new SSH key"

NOTE: When entering the paraphrase, it doesn't display as you type best to type in editor, copy and paste.

Next, click go to "Add a new SSH Key" and follow the instructions

 Go to Github and click on your profile then settings. locate "SSH and GP keys" click on it and
 follow the instructions to add your new SSH key. This will make your machine identifiable to github and avoid
 password prompt whenever you run a push command.


##git push

used to push changes from your machine to remote repositories. code - git push <remote label(origin)> <branch>

You can push any branch to a remote repository without first switching to the branch.


To check what is in the remote repo - git checkout <lable>/branch (origin/master)>

There's a difference when you work with a repo you cloned from github and when you connect the repo you have on
your machine to one on github and push changes there.
You don't get to see if there's a difference between the branch on your machine and one on github
git branch -r only shows you the branch you are connected to and not all the branches in your github repo
Once you perform a fetch request, all the branches in the repo will be accessible with git branch -r

To connect to a branch in your remote repo on your machine use - git switch <thebranch>
git will start tracking changes between the branch on your machine and the one on the remote repo.


##git fetch - used to download changes from remote repo to your local repo but not to your workspace. 
The downloaded changes doesn't clash or merge with your local repo.

git fetch <remote label> <branch> This will fetch a particular branch from the remote and not the whole branch.

To see changes by order contributors on the remote repo on your machine, you have perform a fetch request.
These changes won't be tracked by git on you local machine until you fetch

To track changes in your remote when you did not clone the remote repo, you can use
git push --set-upstream origin master (This will connect the mast branch in your local machine to the master branch
in your remote repo branch)
This way git can track the changes.


##git pull
code - git pull <remote label> <branch>
This will fetch and merge the changes from your remote branch to your working directory.
Unlike push, pull goes to the branch where the pull request was made.

NOTE: Best to initiate pull request from the branch that has he name with the branch in your remote

##pull merge conflict 
Best practice is to use git fetch to peak if the difference between your working directory


When you run a git pull without specifying the remote name and branch, git wil default to origin and the remote
branch being tracked in the branch your in in your local machine 


##README.md
Based on markdown. You can use markdown to generate different things and have a beautiful README for your project


##github gists used to share short codes and comments without having to go through the repo hassle.


##pull request
This used to inform members of your team of changes made to a branch our working on so the person that
have authority to merge your changes to the main branch can review the changes and merge it.
This is a github feature and not on git

##fork
This makes you a copy of a github repo on your account so can manipulate as you like.
When you have made contribution or changes to the fork on your machine you can perform a pull request
so the owner of the original can review and merge to the original repo if they find it good enough.
This is a way to contribute to open source projects.

When you fork a project it doesn't transfer to your local machine rather you will have to clone the
project to be able to work on it on your local machine.

If you want to keep track of changes in the original repo, you can create a new remote and connect to the
original so you can pull from the original whenever.

##git rebase
Used to re-arrange history. When you have a lot of merging resulting in unorganized history you can 
use git rebase to have a more linear history. When using merge commit, you commits will have two or more parents.
git rebase will re-arrange the commits in a way that the commit in your master branch and the branched you rebased
will have different parents. Those on master will come first followed by those on your rebased branched.
the commit hash for the branch you rebased changes while that of the master or any branch you merged it with
remains.

When there is a git rebase conflict, resolve the merge conflict, add the new changes git add <filename>
and continue the rebase operation with git rebase --continue

git rebase -i HEAD~<commit position> used to make changes to commits in a branch.
i - interactive mode. Here you can decide to
rebase pick - No changes to commit
rebase reword - used to change the commit message in a branch
rebase edit - used to amend changes to the commit/or reword the commit message
rebase drop - used to delete commit
rebase fixup - used to join a commit to the next commit after it
rebase squash - used to combines commits into one

##git tag - used to mark version releases. firs number is major release, second is minor release, third is patch.
The above is known as semantic version
To list all tags in a repo use git tag
To search for specific versions use git tag -l "*<num>*" *something comes before or after e.g
git tag -l "*beta*" This will list all beta versions.
When you use - git tag The tag name is added to the last commit, your current HEAD.
To add tag to an earlier commit - git tag <tag name> <commit hash>

You can compare tags with diff git diff <tag version> <tag version>

Two types of tags 
lightweight tags - git tag <tagname> 
Annotated tag - tag with more information like a commit message. git tag -a <tag name>
You can the massage inline without waiting for editor to pop up - git tag -a <tag name> -m "tag detail"
You can also tag a previous commit with Annotated tag - git tag -a <tag name> <commit hash>
To show tag detail - git show <tag name>

Tag names are unique. To move a tag to another commit you have to force it. git tag -f <tag name>